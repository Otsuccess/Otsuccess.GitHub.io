



# 2020年6月-2021年1月学习总结

## 一、学习内容：

### 1. HTML+CSS+JavaScript   

#### 基础知识

 一个网站由多个网页组成，一个网页则有html、css和js构成。

- html是主体，装载显示各种dom元素，属于结构框架层。
- css用来装饰dom元素，属于显示表现层。
- javascript用来控制dom元素，属于动作交互层。

##### HTML

###### 什么是HTML

HTML 是用来描述网页的一种语言。

- HTML 指的是超文本标记语言: HyperText Markup Language
- HTML 不是一种编程语言，而是一种标记语言
- 标记语言是一套标记标签 (markup tag)
- HTML 使用标记标签来描述网页
- HTML 文档包含了HTML 标签及文本内容
- HTML文档也叫做 web 页面

###### HTML标签

HTML 标记标签通常被称为 HTML 标签 (HTML tag)。

-  HTML 标签是由尖括号包围的关键词，比如 <html>
-  HTML 标签通常是成对出现的
-  标签对中的第一个标签是开始标签，第二个标签是结束标签
-  开始和结束标签也被称为开放标签和闭合标签

###### HTML版本

从初期的网络诞生后，已经出现了许多HTML版本:

![img](file:///C:\Users\82604\AppData\Local\Temp\ksohtml33276\wps1.jpg) 

###### HTML4、HTML5对比

①标记方法的改变

- DOCTYPE申明

  - HTML4

    ```
    <！DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd“>
    ```

  - HTML5

    ```
     <！DOCTYPE html>
    ```

- 指定字符编码

  - HTML4
    使用meta元素的形式指定文件中的字符编码(通过 content元素的属性来指定)：

    <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">

  - HTML5
    使用对<meta>元素直接追加charset属性的方式来指定字符编码。  

    <meta charset="UTF-8">

②HTML5确保的兼容性

- 可以省略元素标记：html、head、body、colgroup、tbody 等

- 具有boolean值的属性调整
- 可省略引号

③HTML5新增和废除一些元素

④HTML5增加DOM扩展

⑤HTML5新增API

- 文件API
- 拖放API

⑥HTML5与服务器的新通信方式

- WebSocket

⑦HTML5局部模块复用

- Import、embed、object方法

##### CSS

什么是 CSS?

- CSS 指层叠样式表 (**C**ascading **S**tyle **S**heets)
- 样式定义如何显示 HTML 元素
- 样式通常存储在样式表中
- 把样式添加到 HTML 4.0 中，是为了解决内容与表现分离的问题
- 外部样式表可以极大提高工作效率
- 外部样式表通常存储在 CSS 文件中
- 多个样式定义可层叠为一个

##### JavaScript

JavaScript 是脚本语言

- JavaScript 是一种轻量级的编程语言。
- JavaScript 是可插入 HTML 页面的编程代码。
- JavaScript 插入 HTML 页面后，可由所有的现代浏览器执行。

#### Web页面渲染机制

输入的网址在通过DNS解析后得到服务器地址，浏览器向服务器发起http请求。浏览器接收到代码后进行解析，经过三大步骤：DOM构造、布局以及绘制页面，最终展现为人人都能看懂的网页。

###### 构建DOM树及CSSOM树

1. DOM树

   DOM节点树中节点与HTML文档中内容一一对应，DOM树构建过程：读取html文档，将字节转换成字符，确定tokens（标签），再将tokens转换成节点，以节点构建 DOM 树。

   <img src="C:\Users\82604\AppData\Roaming\Typora\typora-user-images\image-20210201033219407.png" alt="image-20210201033219407"  />

   <img src="C:\Users\82604\AppData\Roaming\Typora\typora-user-images\image-20210201033235203.png" alt="image-20210201033235203" style="zoom: 80%;" />

2. CSSOM树

   CSS文档中，所有元素皆是节点，与HTML文件中的标签节点一一对应。CSS中各节点之间同样拥有层级关系，如父子关系、兄弟关系等，彼此相连，构成CSSOM树。

   在构建DOM树的过程中，在 HTML 文档的 head 标签中遇到 link 标签，该标签引用了一个外部CSS样式表。由于预见到需要利用该CSS资源来渲染页面，浏览器会立即发出对该CSS资源的请求，并进行CSSDOM树的构建。

   CSSOM树构建过程与DOM树构建流程一致：读取CSS文档，将字节转换成字符，确定tokens（标签），再将tokens转换成节点，以节点构建 CSSOM 树。如下图所示：

   <img src="C:\Users\82604\AppData\Roaming\Typora\typora-user-images\image-20210201033842384.png" alt="image-20210201033842384" style="zoom: 67%;" />

###### 构建渲染树

渲染树（Render Tree）由DOM树、CSSOM树合并而成，但并不是必须等DOM树及CSSOM树加载完成后才开始合并构建渲染树。三者的构建并无先后条件，亦非完全独立，而是会有交叉，并行构建。因此会形成一边加载，一边解析，一边渲染的工作现象。

构建渲染树，根据渲染树布局计算每个对象的精确位置和大小，并输出到绘制流程，将像素渲染到屏幕上。

<img src="C:\Users\82604\AppData\Roaming\Typora\typora-user-images\image-20210201034043304.png" alt="image-20210201034043304" style="zoom: 67%;" />

###### 绘制页面

布局完成之后，我们在页面上其实是看不到任何内容的，浏览器只是计算出了每一个节点对象应该被放到页面的哪个位置上，但并没有可视化。

因此最后一步就是将所有内容绘制出来。调用每个Render树节点的paint方法，把他们绘制出来完成整个页面的渲染。

### 2. JavaScript各类开发方法和开源库

#### Echarts

ECharts 是一个使用 JavaScript 实现的开源可视化库，涵盖各行业图表，满足各种需求，遵循 Apache-2.0 开源协议，免费商用。兼容当前绝大部分浏览器（IE8/9/10/11，Chrome，Firefox，Safari等）及兼容多种设备，可随时随地任性展示。

ECharts 包含了以下特性：

- 丰富的可视化类型: 提供了常规的折线图、柱状图、散点图、饼图、K线图，用于统计的盒形图，用于地理数据可视化的地图、热力图、线图，用于关系数据可视化的关系图、treemap、旭日图，多维数据可视化的平行坐标，还有用于 BI 的漏斗图，仪表盘，并且支持图与图之间的混搭。
- 多种数据格式无需转换直接使用: 内置的 dataset 属性（4.0+）支持直接传入包括二维表，key-value 等多种格式的数据源，此外还支持输入 TypedArray 格式的数据。
- 千万数据的前端展现: 通过增量渲染技术（4.0+），配合各种细致的优化，ECharts 能够展现千万级的数据量。
- 移动端优化: 针对移动端交互做了细致的优化，例如移动端小屏上适于用手指在坐标系中进行缩放、平移。 PC 端也可以用鼠标在图中进行缩放（用鼠标滚轮）、平移等。
- 多渲染方案，跨平台使用: 支持以 Canvas、SVG（4.0+）、VML 的形式渲染图表。
- 深度的交互式数据探索: 提供了 图例、视觉映射、数据区域缩放、tooltip、数据刷选等开箱即用的交互组件，可以对数据进行多维度数据筛取、视图缩放、展示细节等交互操作。
- 多维数据的支持以及丰富的视觉编码手段: 对于传统的散点图等，传入的数据也可以是多个维度的。
- 动态数据: 数据的改变驱动图表展现的改变。
- 绚丽的特效: 针对线数据，点数据等地理数据的可视化提供了吸引眼球的特效。
- 通过 GL 实现更多更强大绚丽的三维可视化: 在 VR，大屏场景里实现三维的可视化效果。
- 无障碍访问（4.0+）: 支持自动根据图表配置项智能生成描述，使得盲人可以在朗读设备的帮助下了解图表内容，让图表可以被更多人群访问！

#### SpreadJS

SpreadJS 是一款基于 HTML5 的纯 JavaScript 电子表格和网格功能控件，以“高速低耗、纯前端、零依赖”为产品特色，可嵌入任何操作系统，同时满足 .NET、Java、响应式 Web 应用及移动跨平台的表格数据处理和类 Excel 的表格应用开发，为用户提供更快捷、更安全、更熟悉的表格数据处理方式和更友好的类 Excel 操作体验。

#### jQuery

jQuery 是一个 JavaScript 函数库，包含以下特性：

- HTML 元素选取
- HTML 元素操作
- CSS 操作
- HTML 事件函数
- JavaScript 特效和动画
- HTML DOM 遍历和修改
- AJAX
- Utilities

可以通过下面的标记把 jQuery 添加到网页中：

```
<head>
<script type="text/javascript" src="jquery.js"></script>
</head>
```

#### AJAX

AJAX 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。

- AJAX = 异步 JavaScript 和 XML。
- AJAX 是一种用于创建快速动态网页的技术。
- 通过在后台与服务器进行少量数据交换，AJAX 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。
- 传统的网页（不使用 AJAX）如果需要更新内容，必需重载整个网页面。

#### Font Awesome

fontawesome图标提供丰富的矢量字体图标—通过CSS可以任意控制所有图标的大小 ，颜色，阴影。 

Font Awesome 特性：

- 只需一种字体，同时拥有多个图标。
- 无需JavaScript：Font Awesome不依赖于JS。
- 中文版Font Awesome 提供了IE7+以上兼容性解决方案：可无限放大缩小，使用和普通字体一样自由便捷，可任意缩放 。
- 完全免费：完全免费，可以用于商业用途， SIL OFL 1.1 协议 。
- CSS可控性：通过CSS可以任意控制所有图标的大小 ，颜色，阴影。 
- 完全兼容视网膜屏：由于fontawesome是矢量字体，可以完全兼容视网膜屏 。
- 良好兼容性：能和Bootstrap等常用UI框架一起使用
- 幕阅读器：不像其它字体那样， 它可以兼容屏幕阅读器。

### 3. YANG 数据建模语言

YANG是一种数据建模语言，用于对配置数据、状态数据、远程过程调用和网络管理协议通知进行建模。

YANG是最初设计用于为NETCONF协议建模的语言。NETCONF需要对设备的配置和状态做操作，例如编辑配置，获取状态，因此需要一种语言来对配置和状态进行建模，甚至连“操作”也可以通过YANG来建模。建好的模型，最后以XML的形式进行实例化。

YANG 数据建模语言是结构化语言：

- 每个数据模型都是一个`module`独立的顶级节点层次结构。
- 数据类型可以`imported`来自另一个YANG模块，也可以在模块中定义。
- 用`containers`对相关节点分组。
- 用`lists`表示按顺序存储的节点。
- 用`leaf`表示节点的每个单独属性。
- 每个叶子必须有一个相关的`type`。

```
module ietf-interfaces {
  import ietf-yang-types {
    prefix yang;
  }
  container interfaces {
    list interface {
      key "name";
      leaf name {
        type string;
      }
      leaf enabled {
        type boolean;
        default "true";
    }
}
```

### 4.OpenFlow

OpenFlow，是一种网络通信协议，属于数据链路层，能够控制网上交换器或路由器的转发平面，借此改变网络数据包所走的网络路径。这个协议的发明者，将它当成软件定义网络的启动器。

同时，OpenFlow允许不同供应商用一个简单，开源的协议去远程管理交换机（通常提供专有的接口和描述语言）。

#### OpenFlow网络组成

所谓OpenFlow网络指的是相互连接的一组OpenFlow交换机的集合，并且这些交换机全部置于一个OpenFlow Controller或一个OpenFlow Controller的集群管理之下。分为以下三部分：

- OpenFlow交换机 ——实现数据层的转发（整个OpenFlow网络的核心部件）

- Flow Visor ——对网络进行虚拟化，部署在标准OpenFlow控制器和OpenFlow交换机之间，成为二者的透明代理。FlowVisor能够与多个控制器连接使得每个控制器控制一个虚网，保证各虚网相互隔离。
- Controller ——对网络集中控制，在Controller中，可以用python等程序对其功能进行定义，比如下发流表，对Packet_in包进行处理等。

#### OpenFlow应用

目前，关于OpenFlow/SDN的研究领域主要包括网络虚拟化、安全和访问控制、负载均衡、聚合网络和绿色节能等方面。另外，还有关于OpenFlow和传统网络设备交互和整合等方面的研究。

- 网络虚拟化 – FlowVisor

  网络虚拟化的本质是要能够抽象底层网络的物理拓扑，能够在逻辑上对网络资源进行分片或者整合，从而满足各种应用对于网络的不同需求。为了达到网络分片的目的，FlowVisor实现了一种特殊的OpenFlow Controller，可以看作其他不同用户或应用的Controllers与网络设备之间的一层代理。因此，不同用户或应用可以使用自己的Controllers来定义不同的网络拓扑，同时FlowVisor又可以保证这些Controllers之间能够互相隔离而互不影响。下图展示了使用FlowVisor可以在同一个物理网络上定义出不同的逻辑拓扑。FlowVisor不仅是一个典型的OpenFlow应用案例，同时还是一个很好的研究平台，目前已经有很多研究和应用都是基于FlowVisor做的。

  <img src="C:\Users\82604\AppData\Roaming\Typora\typora-user-images\image-20210201043043550.png" alt="image-20210201043043550" style="zoom:80%;" />

- 负载均衡 – Aster*x

  传统的负载均衡方案一般需要在服务器集群的入口处，通过一个gateway(网关)或者router来监测、统计服务器工作负载，并据此动态分配用户请求到负载相对较轻的服务器上。既然网络中所有的网络设备都可以通过OpenFlow进行集中式的控制和管理，同时应用服务器的负载可以及时地反馈到OpenFlowController那里，那么OpenFlow就非常适合做负载均衡的工作。Aster*x通过Host Manager和Net Manager来分别监测服务器和网络的工作负载，然后将这些信息反馈给FlowManager，这样Flow Manager就可以根据这些实时的负载信息，重新定义网络设备上的OpenFlow规则，从而将用户请求（即网络包）按照服务器的能力进行调整和分发。

  ![image-20210201043149650](C:\Users\82604\AppData\Roaming\Typora\typora-user-images\image-20210201043149650.png)

- 绿色节能的网络服务 – ElasticTree

  ElasticTree创新性地使用OpenFlow，在不影响性能的前提下，根据网络负载动态规划路由，从而可以在网络负载不高的情况下选择性地关闭或者挂起部分网络设备，使其进入节电模式达到节能环保、降低运营成本的目的。

  ![image-20210201043244755](C:\Users\82604\AppData\Roaming\Typora\typora-user-images\image-20210201043244755.png)

### 5.Node.js

Node.js的是建立在Chrome的JavaScript的运行时，可方便地构建快速，可扩展的网络应用程序的平台。Node.js使用事件驱动，非阻塞I/O模型，轻量、高效，可以完美地处理时时数据，运行在不同的设备上。

为什么要使用Node.js：

- Nodejs基于Javascript语言，不用再单独新学一门陌生的语言，从而减低了学习的门槛。同时，Javascript语言在Web前端开发中至 关重要，特别HTML5的应用必须要使用，所以前后台统一语言，不仅可以实现程序员的全栈开发，还可以统一公共类库，代码标准化。单凭这一 点，Nodejs就已经赢得市场的青睐了。
- Nodejs并没有重新开发运行时环境，而是选择了目前最快的浏览器内核V8做为执行引擎，保证了Nodejs的性能和稳定性。

### 6.Vue.js

Vue 是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。

#### Vue目录结构

| 目录/文件    | 说明                                                         |
| :----------- | ------------------------------------------------------------ |
| build        | 项目构建(webpack)相关代码                                    |
| config       | 配置目录，包括端口号等。我们初学可以使用默认的。             |
| node_modules | npm 加载的项目依赖模块                                       |
| src          | 这里是我们要开发的目录，基本上要做的事情都在这个目录里。里面包含了几个目录及文件：assets: 放置一些图片，如logo等。components: 目录里面放了一个组件文件，可以不用。App.vue: 项目入口文件，我们也可以直接将组件写这里，而不使用 components 目录。main.js: 项目的核心文件。 |
| static       | 静态资源目录，如图片、字体等。                               |
| test         | 初始测试目录，可删除                                         |
| .xxxx文件    | 这些是一些配置文件，包括语法配置，git配置等。                |
| index.html   | 首页入口文件，你可以添加一些 meta 信息或统计代码啥的。       |
| package.json | 项目配置文件。                                               |
| README.md    | 项目的说明文档，markdown 格式                                |

#### Vue 组件

组件（Component）是 Vue.js 最强大的功能之一，可以扩展 HTML 元素，封装可重用的代码。组件系统让我们可以用独立可复用的小组件来构建大型应用，几乎任意类型的应用的界面都可以抽象为一个组件树：

<img src="C:\Users\82604\AppData\Roaming\Typora\typora-user-images\image-20210201045803806.png" alt="image-20210201045803806" style="zoom:80%;" />

#### Vue虚拟DOM

##### 虚拟DOM定义

运行的js速度是很快的，大量的操作DOM就会很慢，时常在更新数据后会重新渲染页面，这样造成在没有改变数据的地方也重新渲染了DOM节点，这样就造成了很大程度上的资源浪费。

利用在内存中生成与真实DOM与之对应的数据结构，这个在内存中生成的结构称之为虚拟DOM

当数据发生变化时，能够智能地计算出重新渲染组件的最小代价并应用到DOM操作上

##### 虚拟dom原理流程

模板 ==> 渲染函数 ==> 虚拟DOM树 ==> 真实DOM

- vuejs通过编译将模板（template）转成渲染函数（render），执行渲染函数可以得到一个虚拟节点树
- 在对 Model 进行操作的时候，会触发对应 Dep 中的 Watcher 对象。Watcher 对象会调用对应的 update 来修改视图。

虚拟 DOM 的实现原理主要包括以下 3 部分：

1. 用 JavaScript 对象模拟真实 DOM 树，对真实 DOM 进行抽象；
2. `diff 算法` — 比较两棵虚拟 DOM 树的差异；
3. `pach 算法` — 将两个虚拟 DOM 对象的差异应用到真正的 DOM 树

##### 虚拟DOM好处

- 具备跨平台的优势–由于 Virtual DOM 是以 JavaScript 对象为基础而不依赖真实平台环境，所以使它具有了跨平台的能力，比如说浏览器平台、Weex、Node 等。
- 操作 DOM 慢，js运行效率高。我们可以将DOM对比操作放在JS层，提高效率。运用patching算法来计算出真正需要更新的节点，最大限度地减少DOM操作，从而显著提高性能。Virtual DOM 本质上就是在 JS 和 DOM 之间做了一个缓存。
- 提升渲染性能 Virtual DOM的优势不在于单次的操作，而是在大量、频繁的数据更新下，能够对视图进行合理、高效的更新
- 虚拟DOM就是为了解决浏览器性能问题而被设计出来的

#### vue生命周期

##### 生命周期定义

Vue 实例从创建到销毁的过程，就是生命周期。也就是从开始创建、初始化数据、编译模板、挂载Dom→渲染、更新→渲染、卸载等一系列过程，我们称这是 Vue 的生命周期。

<img src="https://img-blog.csdnimg.cn/20200928091034818.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poYW5ndmFsdWU=,size_16,color_FFFFFF,t_70" alt="img" style="zoom: 50%;" />

##### 生命周期函数

Vue 的生命周期总共分为8个阶段：创建前/后，载入前/后，更新前/后，销毁前/后。

1）beforeCreate（创建前）

表示实例完全被创建出来之前，vue 实例的挂载元素$el和数据对象 data 都为 undefined，还未初始化。

2）created（创建后）

数据对象 data 已存在，可以调用 methods 中的方法，操作 data 中的数据，但 dom 未生成，$el 未存在 。

3）beforeMount（挂载前）

vue 实例的 $el 和 data 都已初始化，挂载之前为虚拟的 dom节点，模板已经在内存中编辑完成了，但是尚未把模板渲染到页面中。data.message 未替换。

4）mounted（挂载后）

vue 实例挂载完成，data.message 成功渲染。内存中的模板，已经真实的挂载到了页面中，用户已经可以看到渲染好的页面了。实例创建期间的最后一个生命周期函数，当执行完 mounted 就表示，实例已经被完全创建好了，DOM 渲染在 mounted 中就已经完成了。

5）beforeUpdate（更新前）

当 data 变化时，会触发beforeUpdate方法 。data 数据尚未和最新的数据保持同步。

6）updated（更新后）

当 data 变化时，会触发 updated 方法。页面和 data 数据已经保持同步了。

7）beforeDestory（销毁前）

组件销毁之前调用 ，在这一步，实例仍然完全可用。

8）destoryed（销毁后）

组件销毁之后调用，对 data 的改变不会再触发周期函数，vue 实例已解除事件监听和 dom绑定，但 dom 结构依然存在。

#### Vue网络通信Axios

##### Axios是什么？

Axios是一个基于promise的HTTP库，类似于jQuery的ajax，用于http请求。可以应用于浏览器端和node.js，既可以用于客户端，也可以用于node.js编写的服务端。

##### Axios特性

（1）支持Promise API

（2）拦截请求与响应，比如：在请求前添加授权和响应前做一些事情。

（3）转换请求数据和响应数据，比如：进行请求加密或者响应数据加密。

（4）取消请求

（5）自动转换JSON数据

（6）客户端支持防御XSRF

##### 浏览器支持情况

Firefox、Chrome、Safari、Opera、Edge、IE8+

## 二、主要成果（相关技术和学习方式）：

### 1. JS表格编辑器

#### 相关技术

- HTML
- CSS
- JavaScript 
- jQuery函数库
- Echarts图表库

#### 主要功能+实现效果+相关代码

###### 生成表格

根据输入行、列数自动生成表格。

- 实现效果：

  根据输入6、6点击“生成表格”，页面下方自动生成一个6行6列的表格：

<img src="C:\Users\82604\AppData\Roaming\Typora\typora-user-images\image-20210201054338765.png" alt="image-20210201054338765" style="zoom: 80%;" />

- 相关代码：

  <img src="C:\Users\82604\AppData\Roaming\Typora\typora-user-images\image-20210201054817926.png" alt="image-20210201054817926" style="zoom: 67%;" />

###### 添加行、列，删除行、列

动态为表格添加一行、一列，删除一行、一列。

- 相关代码：

  添加一行/列表格。

  <img src="C:\Users\82604\AppData\Roaming\Typora\typora-user-images\image-20210201055135118.png" alt="image-20210201055135118" style="zoom: 67%;" />

  <img src="C:\Users\82604\AppData\Roaming\Typora\typora-user-images\image-20210201055521941.png" alt="image-20210201055521941" style="zoom: 80%;" />

  删除一行/列表格。

![image-20210201055313652](C:\Users\82604\AppData\Roaming\Typora\typora-user-images\image-20210201055313652.png)

<img src="C:\Users\82604\AppData\Roaming\Typora\typora-user-images\image-20210201055538237.png" alt="image-20210201055538237" style="zoom:80%;" />

###### 修改单元格数据

输入文本，修改指定行列单元格的内容。

- 实现效果：

  修改第一行第一列的单元格数据为hello：

![image-20210201055650111](C:\Users\82604\AppData\Roaming\Typora\typora-user-images\image-20210201055650111.png)

- 相关代码：

  <img src="C:\Users\82604\AppData\Roaming\Typora\typora-user-images\image-20210201055730624.png" alt="image-20210201055730624" style="zoom:80%;" />

###### 修改单元格格式

调整表格的字体颜色、大小和对齐方式。

- 实现效果：

  修改颜色示例。

![image-20210201060003588](C:\Users\82604\AppData\Roaming\Typora\typora-user-images\image-20210201060003588.png)

- 相关代码：

  <img src="C:\Users\82604\AppData\Roaming\Typora\typora-user-images\image-20210201060019881.png" alt="image-20210201060019881" style="zoom:80%;" />

###### 合并、拆分单元格

点击两个相邻单元格进行合并，双击单元格进行拆分，思路如下。

<img src="C:\Users\82604\AppData\Roaming\Typora\typora-user-images\image-20210201053842365.png" alt="image-20210201053842365" style="zoom: 67%;" />

- 实现效果：

  ![image-20210201060156575](C:\Users\82604\AppData\Roaming\Typora\typora-user-images\image-20210201060156575.png)

- 相关代码：

  判断是否第一次单击。

  <img src="C:\Users\82604\AppData\Roaming\Typora\typora-user-images\image-20210201060220657.png" alt="image-20210201060220657" style="zoom:80%;" />

  不是第一次单击→判断两次单击是否为同一个单元格。

  <img src="C:\Users\82604\AppData\Roaming\Typora\typora-user-images\image-20210201060231089.png" alt="image-20210201060231089" style="zoom:80%;" />

  不是第一次单击→判断两次单击是否为同一个单元格→不是→是否相邻→是→合并。

  <img src="C:\Users\82604\AppData\Roaming\Typora\typora-user-images\image-20210201060505374.png" alt="image-20210201060505374" style="zoom:67%;" />

不是第一次单击→判断两次单击是否为同一个单元格→是→是否为合并单元格。

<img src="C:\Users\82604\AppData\Roaming\Typora\typora-user-images\image-20210201060552143.png" alt="image-20210201060552143" style="zoom: 80%;" />

不是第一次单击→两次单击为同一个单元格→单元格是合并单元格→拆分。

<img src="C:\Users\82604\AppData\Roaming\Typora\typora-user-images\image-20210201060653027.png" alt="image-20210201060653027" style="zoom: 80%;" />

###### 自动生成图表

根据表格中给定的数据生成各种图表。

- 实现效果：

  生成柱状图。

![image-20210201060817989](C:\Users\82604\AppData\Roaming\Typora\typora-user-images\image-20210201060817989.png)

<img src="C:\Users\82604\AppData\Roaming\Typora\typora-user-images\image-20210201060846307.png" alt="image-20210201060846307" style="zoom:67%;" />

- 相关代码：

  <img src="C:\Users\82604\AppData\Roaming\Typora\typora-user-images\image-20210201060900787.png" alt="image-20210201060900787" style="zoom: 80%;" />

### 2. JS计算器

#### 相关技术

- HTML
- CSS
- JavaScript 

#### 主要功能

- 简单的加减乘除运算
- 小数运算
- 数字实现屏内数据清零
- 已选数字回退

#### 实现效果

<img src="C:\Users\82604\AppData\Roaming\Typora\typora-user-images\image-20210201061549178.png" alt="image-20210201061549178" style="zoom:67%;" />

#### 相关代码

```
<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>计算器</title>
    <style type="text/css">
        table {
            /* order-collapse 属性设置表格的边框是否被合并为一个单一的边框 */
            border-collapse: collapse;
            margin: auto auto;
        }
        
        td {
            width: 150px;
            line-height: 70px;
        }
        
        .btn {
            width: 150px;
            line-height: 70px;
            font-size: x-large;
        }
        
        .btn_click {
            width: 302px;
            line-height: 70px;
            font-size: x-large;
        }
        
        .txt {
            width: 600px;
            line-height: 100px;
            font-size: x-large;
            text-align: right;
        }
    </style>
</head>

<body>
    <table>
        <tr>
            <td colspan="4"><input class="txt" type="text" disabled /></td>
        </tr>
        <tr>
            <td colspan="2"><input class="btn_click" type="button" value="AC" /></td>
            <td colspan="2"><input class="btn_click" type="button" value="DEL" /></td>
        </tr>
        <tr>
            <td><input class="btn" type="button" value="7" /></td>
            <td><input class="btn" type="button" value="8" /></td>
            <td><input class="btn" type="button" value="9" /></td>
            <td><input class="btn" type="button" value="*" /></td>
        </tr>
        <tr>
            <td><input class="btn" type="button" value="4" /></td>
            <td><input class="btn" type="button" value="5" /></td>
            <td><input class="btn" type="button" value="6" /></td>
            <td><input class="btn" type="button" value="/" /></td>
        </tr>
        <tr>
            <td><input class="btn" type="button" value="1" /></td>
            <td><input class="btn" type="button" value="2" /></td>
            <td><input class="btn" type="button" value="3" /></td>
            <td><input class="btn" type="button" value="-" /></td>
        </tr>
        <tr>
            <td><input class="btn" type="button" value="0" /></td>
            <td><input class="btn" type="button" value="." /></td>
            <td><input class="btn" type="button" value="+" /></td>
            <td><input class="btn" type="button" value="=" /></td>
        </tr>
    </table>

    <script>
        /* 在网页加载时 给按钮添加点击事件 */
        window.onload = function() { //定义数组 用来接收用户按的数字和计算符号 
            var way_res = []; //获取按钮对象 
            var btn_txt = document.getElementsByClassName("btn");

            //获取屏幕元素 
            var txt = document.getElementsByClassName("txt")[0];
            //获取清空按钮和退格按钮 
            var btn_way = document.getElementsByClassName("btn_click");
            for (var i = 0; i < btn_way.length; i++) {
                btn_way[i].onclick = function() {
                    if (this.value == "AC") {
                        way_res = [];
                        txt.value = "";
                    } else { //用数组对实际没有 影响 
                        txt.value = txt.value.substr(0, txt.value.length - 1);
                    }
                }
            }
            //给btn_txt 数组对象添加事件 
            for (var i = 0; i < btn_txt.length; i++) {
                btn_txt[i].onclick = function() {
                    //按完键将赋值传给屏幕 
                    //判断是否为数字 
                    if (txt.value == "" && this.value == ".") {
                        txt.value = "0.";
                    } else {
                        //isNaN false:合法数字 true：非合法数字 
                        //合法的数字或者点
                        if (!isNaN(this.value) || this.value == ".") {
                            //indexOf()用来查找字符，如果有返回当前位置 如果没有返回 -1 
                            if (txt.value.indexOf(".") != -1) {
                                //有点存在的情况 
                                if (this.value != ".") {
                                    //当前按的不是点，进行拼接 
                                    txt.value += this.value;
                                }
                            } else { //没有点存在，直接拼接 
                                txt.value += this.value;
                            }
                        } else {
                            //是符号的情况 
                            //先存值 再清屏 
                            if (this.value != "=") {
                                //是符号但不是等号 
                                way_res[way_res.length] = txt.value;
                                //存符号 
                                way_res[way_res.length] = this.value;
                                //清屏 
                                txt.value = "";
                            } else { //是等号的情况
                                way_res[way_res.length] = txt.value;
                                //eval() 计算表达式的值
                                //join() 将数组拼接成字符串
                                txt.value = eval(way_res.join(""));
                                //计算完成清空数组
                                way_res = [];
                            }
                        }
                    }
                }
            }
        }
    </script>
</body>

</html>
```

### 3. JS轮播图

#### 相关技术

- HTML
- CSS
- JavaScript 

#### 主要功能

- 页面自动轮播图片
- 光标放置在图片区域时，固定当前图片在页面，停止轮播
- 鼠标移入右下角圆标，页面显示对应次序的图片
- 通过鼠标选择上/下一张图片

#### 实现效果

<img src="C:\Users\82604\AppData\Roaming\Typora\typora-user-images\image-20210201062520550.png" alt="image-20210201062520550" style="zoom:80%;" />

#### 相关代码

```
<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <title>轮播图</title>
    <style>
        * {
            margin: 0px;
            padding: 0px;
            list-style: none;
            text-decoration: none;
        }
        
        #flash {
            /*根据图片的大小来设置外层div的大小*/
            width: 600px;
            height: 400px;
            margin: 100px auto;
            position: relative;
            /*设置div定位，方便之后图片及圆点位置的设定*/
            border: 1px solid white;
        }
        
        #flash img {
            width: 100%;
            height: 100%;
            position: absolute;
            /*设置所有图片重叠*/
            left: 0px;
            top: 0px;
            display: none;
            /*设置所有图片隐藏，通过改变第一个图片的行间样式来使第一个图片显示*/
        }
        
        #flash ul {
            width: 150px;
            height: 25px;
            border-radius: 20px;
            background-color: rgba(255, 255, 255, 0.5);
            position: absolute;
            left: 35%;
            bottom: 10%;
        }
        
        #flash ul li {
            width: 12px;
            height: 12px;
            margin-top: 5px;
            background-color: #fff;
            border-radius: 50%;
            margin-left: 15px;
            float: left;
        }
        
        #flash ul .li_1 {
            background-color: #f40;
            /*设置第一个圆点背景色为红色*/
        }
        
        #flash .span-r {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            position: absolute;
            right: 2%;
            top: 45%;
            background-color: rgba(255, 255, 255, 0.5);
        }
        
        #flash .span-r span {
            width: 100%;
            height: 100%;
            color: rgba(0, 0, 0, 0.5);
            font-size: xx-large;
            font-weight: 700;
            line-height: 50px;
            margin-left: 15px;
            cursor: pointer;
        }
        
        #flash .span-l {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            position: absolute;
            left: 2%;
            top: 45%;
            background-color: rgba(255, 255, 255, 0.5);
        }
        
        #flash .span-l span {
            width: 100%;
            height: 100%;
            color: rgba(0, 0, 0, 0.5);
            font-size: xx-large;
            font-weight: 700;
            line-height: 50px;
            margin-left: 15px;
            cursor: pointer;
        }
    </style>
</head>
<div id="flash">
    <img src="/picture/timg (1).jpg" alt="" style="display: block">
    <img src="/picture/timg2.jpg" alt="">
    <img src="/picture/u=2429928237,2739199171&fm=26&gp=0.jpg" alt="">
    <img src="/picture/u=2454215018,475953245&fm=26&gp=0.jpg" alt="">
    <img src="/picture/u=2214279671,1299042480&fm=26&gp=0.jpg" alt="">
    <ul>
        <li class="li_1"></li>
        <li></li>
        <li></li>
        <li></li>
        <li></li>
    </ul>
    <div class="span-r">
        <span>></span>
    </div>
    <div class="span-l">
        <span><</span>
    </div>
</div>

<body>
    <script>
        var div = document.getElementById('flash');
        var img = div.getElementsByTagName('img'); /*选中div下所有的图片*/
        var ul = document.getElementsByTagName('ul')[0];
        var li = ul.getElementsByTagName('li');
        var div_r = document.getElementsByTagName('div')[1];
        // var span_r = div_r.getElementsByTagName('span');
        var div_l = document.getElementsByTagName('div')[2];
        // var sapn_l = div_l.getElementsByTagName('span');
        var len = img.length;
        var count = 0; /*设置count来显示当前图片的序号*/
        function run() { /*将定时器里的函数提取到外部*/
            count++;
            count = count == 5 ? 0 : count; /*当图片加载到最后一张时，使其归零*/
            for (var i = 0; i < len; i++) {
                img[i].style.display = 'none'; /*利用for循环使除当前count位其他图片隐藏*/
            }
            img[count].style.display = 'block'; /*显示当前count的值所代表的图片*/
            for (var i = 0; i < li.length; i++) {
                li[i].style.backgroundColor = "#fff"; /*原理同上*/
            }
            li[count].style.backgroundColor = "#f40";
        }
        var timer = setInterval(run, 3000); /*定义定时器，使图片每隔3s更换一次*/
        div.onmouseover = function() {
            clearInterval(timer);
        }
        div.onmouseleave = function() { /*定义鼠标移出事件，当鼠标移出div区域，轮播继续*/
            timer = setInterval(run, 3000);
        }
        for (var i = 0; i < len; i++) {
            li[i].index = i; /*定义index记录当前鼠标在li的位置*/
            li[i].onmouseenter = function() { /*定义鼠标经过事件*/
                for (var i = 0; i < len; i++) { /*通过for循环将所有图片隐藏，圆点背景设为白色*/
                    li[i].style.background = '#fff';
                    img[i].style.display = 'none';
                }
                this.style.background = '#f40'; /*设置当前所指圆点的背景色*/
                img[this.index].style.display = 'block'; /*使圆点对应的图片显示*/
            }
        }
        div_r.onclick = function() { /*因为span没有设置宽高，直接把事件添加到他的父级*/
            run(); /*直接调用现成的run函数*/
        }

        function reverse() {
            count--;
            count = count == -1 ? 4 : count;
            for (var i = 0; i < len; i++) {
                img[i].style.display = 'none'; /*利用for循环使除当前count位其他图片隐藏*/
            }
            img[count].style.display = 'block'; /*显示当前count的值所代表的图片*/
            for (var i = 0; i < li.length; i++) {
                li[i].style.backgroundColor = "#fff"; /*原理同上*/
            }
            li[count].style.backgroundColor = "#f40";
        }
        div_l.onclick = function() {
            reverse(); /*重新设置函数*/
        }
    </script>
</body>

</html>
```

### 4. 文件资源管理器登陆-注册界面

#### 相关技术

- HTML
- CSS
- JavaScript 
- Jquery
- Ajax

#### 主要功能

- 判断邮箱格式是否正确
- 向后端发送请求判断邮箱地址是否已被注册
- 判断两次密码是否输入一致
- 向后端发送请求发送验证码至邮箱
- 限制邮件发送时间间隔
- 向后端发送请求判断验证码是否输入正确
- 点击注册时判断邮箱/密码/验证码是否为空，不为空的话是否正确，正确则允许注册
- 注册成功即跳转到登录界面

#### 实现效果

![image-20210201064953844](C:\Users\82604\AppData\Roaming\Typora\typora-user-images\image-20210201064953844.png)

#### 相关代码

- HTML

  ```
  <html>
  <!DOCTYPE html>
  <html lang="en" class="no-js">
  
  <head>
  
      <meta charset="utf-8">
      <title>注册(Register)</title>
      <meta name="author" content="">
  
      <!-- CSS -->
      <link rel="stylesheet" href="assets/css/reset.css">
      <link rel="stylesheet" href="assets/css/registerStyle.css">
      <link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.css">
  </head>
  
  <body>
      <div>
          <div class="register-container">
              <h1>File Browser</h1>
              <!-- <form action=" " method=" "> -->
              <!-- placeholder 属性提供exist可描述输入字段预期值的提示信息（hint）。 该提示会在输入字段为空时显示，并会在字段获得焦点时消失。 -->
              <input type="text" name="username" class="username" id="username" placeholder="请输入邮箱地址！">
              <div>
                  <span class="errorMessage" id="format"><i class="fa fa-exclamation-circle" style="font-size:16px"></i>&nbsp&nbsp邮箱格式错误！</span>
                  <span class="errorMessage" id="exist"><i class="fa fa-exclamation-circle" style="font-size:16px"></i>&nbsp&nbsp该邮箱已被注册！</span>
                  <span class="errorMessage" id="adressNull"><i class="fa fa-exclamation-circle" style="font-size:16px"></i>&nbsp&nbsp邮箱地址不能为空！</span>
              </div>
              <input type="password" name="password" class="password" id="password" placeholder="请设置密码！ ">
              <div>
                  <span class="errorMessage" id="passwordNull"><i class="fa fa-exclamation-circle" style="font-size:16px"></i>&nbsp&nbsp密码不能为空！</span>
              </div>
              <input type="password" name="password" class="passwordAgain" id="passwordAgain" placeholder="请再次确认密码！ ">
              <div>
                  <span class="errorMessage" id="same"><i class="fa fa-exclamation-circle" style="font-size:16px"></i>&nbsp&nbsp两次密码不一致，请重新输入！</span>
              </div>
              <input type="Captcha" class="Captcha" name="identifyCode" id="identifyInput" placeholder=" 请输入验证码！ ">
              <button type="button" class="Mail_button " id="mailButton">获取验证码</button>
              <div>
                  <span class="errorMessage" id="identify"><i class="fa fa-exclamation-circle" style="font-size:16px"></i>&nbsp&nbsp验证码不能为空！</span>
              </div>
              <button type="submit" id="submitButton" class="submit_button ">注册</button>
              <!-- <div class="error "><span>+</span></div> -->
              <!-- </form> -->
  
          </div>
  
      </div>
      <!-- Javascript -->
      <script src="assets/js/jquery-1.8.2.min.js "></script>
      <script src="assets/js/registerScript.js "></script>
  
  </body>
  
  </html>
  ```

- JS

  ```
  var countdown = 60;
  
  function settime(val) {
      if (countdown == 0) {
          val.removeAttribute("disabled");
          val.innerHTML = "获取验证码";
          countdown = 60;
      } else {
  
          console.log("3");
          val.setAttribute("disabled", true);
          //console.log(val.innerHTML);
          val.innerHTML = "重新发送(" + countdown + ")";
  
          countdown--;
          setTimeout(function() {
              settime(val)
          }, 1000)
      }
  
  }
  
  //判断邮箱格式是否正确
  function isEmail(strEmail) {
      //search() 方法用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串。
      //如果没有找到任何匹配的子串，则返回 -1。
      var flag = strEmail.search(/^\w+((-\w+)|(\.\w+))*\@[A-Za-z0-9]+((\.|-)[A-Za-z0-9]+)*\.[A-Za-z0-9]+$/);
      if (flag == -1) {
          return false;
      } else
          return true;
  }
  //判断邮箱是否已注册
  var notExist; //false表示未注册
  
  function whetherExist(strEmail) {
      var username = document.getElementById("username");
      var emailinfo = {
          "Email": username.value, //username邮箱输入框
      }
      $.ajax({
              headers: {
                  "Access-Control-Allow-Origin": "*"
              },
              async: false,
              type: "POST",
              url: "http://localhost:8181/UserCheckServlet", //填入url
              contentType: "application/json",
              dataType: "json",
              data: JSON.stringify(emailinfo),
              success: function(result) {
                  notExist = true;
              },
              error: function(jqXHR, textStatus, errorThrown) {
                  if (jqXHR.status == 401)
                      notExist = false;
                  else if (jqXHR.status == 201)
                      notExist = true;
              }
          })
          //   return notExist;
  
  }
  
  function usernameFocus() {
      username.style.color = "black";
      document.getElementById("format").style.display = "none";
      document.getElementById("exist").style.display = "none";
      document.getElementById("adressNull").style.display = "none";
      sign = 2;
      //alert("black" + sign);
  
  }
  
  
  function passwordFocus() {
      // passwordAgain.style.color = "black";
      document.getElementById("passwordNull").style.display = "none";
  }
  
  function passwordAgainFocus() {
      passwordAgain.style.color = "black";
      document.getElementById("same").style.display = "none";
  }
  
  function identifyFocus() {
      //passwordAgain.style.color = "black";
      document.getElementById("identify").style.display = "none";
  }
  
  window.onload = function() {
      var username = document.getElementById("username");
      // var passwordInput = document.getElementById("password");
      var password = document.getElementById("password");
      var identify = document.getElementById("identifyInput");
      username.onblur = function usernameContentJudge() {
          var i = isEmail(username.value);
          whetherExist(username.value);
          if (i == false && username.value.length > 0) {
              username.style.color = "rgb(246, 66, 66)";
              document.getElementById("format").style.display = "block";
          } else if (notExist == false && username.value.length > 0) {
              username.style.color = "rgb(246, 66, 66)";
              document.getElementById("exist").style.display = "block";
          }
  
      }
      username.addEventListener("focus", usernameFocus);
      password.addEventListener("focus", passwordFocus);
      identify.addEventListener("focus", identifyFocus);
  
      var passwordAgain = document.getElementById("passwordAgain");
  
      passwordAgain.onblur = function passwordAgainContentJudge() {
          // alert("1");
          if (passwordAgain.value != password.value && passwordAgain.value.length > 0) {
              passwordAgain.style.color = "rgb(246, 66, 66)";
              document.getElementById("same").style.display = "block";
          }
      }
      passwordAgain.addEventListener("focus", passwordAgainFocus);
  
  
      //获取验证码
      var sendMailButton = document.getElementById("mailButton");
  
      sendMailButton.onclick = function sendMail() {
          console.log("1");
          if (username.value.length > 0 && isEmail(username.value) && notExist) {
              //获取验证码倒计时
              settime(sendMailButton);
              //发送邮件
              var emailinfo = {
                  "Email": username.value, //username邮箱输入框
              }
              $.ajax({
                  headers: {
                      "Access-Control-Allow-Origin": "*"
                  },
                  type: "POST",
                  url: "http://localhost:8181/emailServlet", //填入url
                  contentType: "application/json",
                  dataType: "json",
                  data: JSON.stringify(emailinfo),
                  success: function(result) {
                      console.log(result)
                  }
              });
          }
      };
  
      $("#submitButton").click(function(e) {
          //console.log(1);
          //阻止默认行为
          var e = e || window.event;
          e.preventDefault();
          if (username.value.length == 0) {
              document.getElementById("adressNull").style.display = "block";
          } else if (password.value.length == 0 && username.style.color == "black")
              document.getElementById("passwordNull").style.display = "block";
          else if (password.value.length > 0 && passwordAgain.value.length == 0 && username.style.color == "black")
              document.getElementById("same").style.display = "block";
          else if (document.getElementById("identifyInput").value.length == 0 && username.style.color == "black" && passwordAgain.style.color == "black")
              document.getElementById("identify").style.display = "block";
          else {
  
              //请求的参数
              var registerInfo = { 'Email': username.value, 'Code': identify.value, 'password': password.value };
  
              $.ajax({
                  headers: {
                      "Access-Control-Allow-Origin": "*"
                  },
                  type: "POST",
                  url: "http://localhost:8181/RegistrationServlet", //填入url
                  contentType: "application/json",
                  dataType: "json",
                  data: (registerInfo),
                  success: function(result) {
                      //跳转到登陆界面
                      window.location.href = "http://127.0.0.1:8181/login.html";
                  },
                  //XMLHttpRequest 对象，错误信息，（可能）捕获的错误对象。
                  error: function(jqXHR, textStatus, errorThrown) {
                      if (jqXHR.status == 403)
                          alert("验证码错误");
                  }
              });
          }
  
      })
  
  }
  ```

### 5. 文件资源管理器登陆-登录界面

#### 相关技术

- HTML
- CSS
- JavaScript 
- Jquery
- Ajax

#### 主要功能

- 用户输入邮箱地址后判断邮箱格式是否正确
- 生成验证码
- 验证码校验
- 点击登录时判断邮箱/密码/验证码是否为空，不为空的话是否正确，正确则允许登录
- 记住密码
- 通过注册链接跳转到注册界面

#### 实现效果

![image-20210201063922293](C:\Users\82604\AppData\Roaming\Typora\typora-user-images\image-20210201063922293.png)

#### 相关代码

- HTML

  ```
  <html>
  <!DOCTYPE html>
  <html lang="en" class="no-js">
  
  <head>
  
      <meta charset="utf-8">
      <title>登录(Login)</title>
      <meta name="author" content="">
  
      <!-- CSS -->
      <link rel="stylesheet" href="assets/css/reset.css">
      <link rel="stylesheet" href="assets/css/style.css">
      <link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.css">
  
  </head>
  
  <body>
  
      <div class="page-container">
          <h1>File Browser</h1>
          <form action=" " method=" ">
              <input type="text" name="username" class="username" id="username" placeholder="请输入您的用户名！ ">
              <div>
                  <span class="errorMessage " id="format"><i class="fa fa-exclamation-circle " style="font-size:16px "></i>&nbsp&nbsp邮箱格式错误！</span>
                  <span class="errorMessage " id="adressNull"><i class="fa fa-exclamation-circle " style="font-size:16px "></i>&nbsp&nbsp邮箱地址不能为空！</span>
              </div>
              <input type="password" name="password " class="password" id="password" placeholder="请输入您的用户密码！ ">
              <div>
                  <span class="errorMessage" id="passwordNull"><i class="fa fa-exclamation-circle " style="font-size:16px "></i>&nbsp&nbsp密码不能为空！&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp</span>
              </div>
              <input type="Captcha" class="Captcha " name="Captcha" id="identify" placeholder="请输入验证码！ ">
              <input type="button" id="code" value="点击生成验证码" title='点击更换验证码' />
              <!-- <div>
                  <span class="errorMessage" id="identifyWrong"><i class="fa fa-exclamation-circle" style="font-size:16px "></i>&nbsp&nbsp验证码错误！</span>
              </div> -->
              <button type="submit" class="submit_button" id="submit_button">登录</button>
              <br/>
              <br/>
              <!-- <input type="checkbox " id="remember_password "> -->
              <!-- <span class="checkbox "><i></i></span> -->
              <input type="checkbox" class="passwordCheckbox" id="rememberCheckbox">
              <span id="remember">记住密码</span> &nbsp&nbsp
              <a href=" ">忘记密码？</a>&nbsp&nbsp<a href="http://127.0.0.1:5501/register.html ">注册账号</a>
          </form>
  
      </div>
  
      <!-- Javascript -->
      <script src="assets/js/jquery-1.8.2.min.js "></script>
      <script src="assets/js/scripts.js "></script>
  
  </body>
  
  </html>
  ```

- JS

  ```
  var code; //在全局定义验证码   
  function changecolor() {
      var colorArray = new Array("0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f");
      var color = "#";
      for (var i = 0; i < 6; i++) {
          color += colorArray[Math.floor(Math.random() * 16)];
      }
      return color;
  }
  
  function createCode() {
      var color1 = 1,
          color2 = 1;
  
      while (color1 == color2) {
          color1 = changecolor();
          color2 = changecolor();
          document.getElementById("code").style.fontWeight = "bolder";
          document.getElementById("code").style.background = color1;
          document.getElementById("code").style.color = color2;
      }
  
      code = "";
      var codeLength = 4; //验证码的长度   
      var checkCode = document.getElementById("code");
      var random = new Array(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R',
          'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'); //随机数   
      for (var i = 0; i < codeLength; i++) { //循环操作   
          var index = Math.floor(Math.random() * 36); //取得随机数的索引（0~35）   
          code += random[index]; //根据索引取得随机数加到code上   
      }
      checkCode.value = code; //把code值赋给验证码  
      console.log(code);
  }
  
  function validate() {
  
      var inputCode = document.getElementById("identify").value.toUpperCase(); //取得输入的验证码并转化为大写         
      if (inputCode != code) { //若输入的验证码与产生的验证码不一致时   
          //alert("验证码错误！")
          createCode(); //刷新验证码   
          document.getElementById("identify").value = ""; //清空文本框 
          return false;
      } else {
          return true;
      }
  }
  
  function suiJi(m, n) {
      return m + parseInt(Math.random() * (n - m + 1));
      console.log("1");
  
  }
  
  function yanSe() {
      var result = "#";
      for (var i = 0; i < 6; i++) {
          result += suiJi(0, 15).toString(16);
      }
      return result;
      //生成一个随机颜色编码#000000-#ffffff
  }
  
  
  
  //判断邮箱格式是否正确
  function isEmail(strEmail) {
      //search() 方法用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串。
      //如果没有找到任何匹配的子串，则返回 -1。
      var flag = strEmail.search(/^\w+((-\w+)|(\.\w+))*\@[A-Za-z0-9]+((\.|-)[A-Za-z0-9]+)*\.[A-Za-z0-9]+$/);
      if (flag == -1) {
          return false;
      } else
          return true;
  }
  
  function usernameFocus() {
      document.getElementById("username").style.color = "black";
      document.getElementById("format").style.display = "none";
      document.getElementById("adressNull").style.display = "none";
  }
  
  function passwordFocus() {
      // passwordAgain.style.color = "black";
      document.getElementById("passwordNull").style.display = "none";
  }
  
  
  function alert(e) {
      $("body").append("<div id='msg'><span>" + e + "</span></div>");
      clearmsg();
  }
  
  function clearmsg() {
      var t = setTimeout(function() {
          $("#msg").remove();
      }, 2000)
  };
  
  window.onload = function() {
      var username = document.getElementById("username");
      var password = document.getElementById("password");
      var identify = document.getElementById("identify");
      var loginButton = document.getElementById("submit_button");
      var idetifyCode = document.getElementById("code");
      username.onblur = function usernameContentJudge() {
          var i = isEmail(username.value);
          if (i == false && username.value.length > 0) {
              username.style.color = "rgb(246, 66, 66)";
              document.getElementById("format").style.display = "block";
          }
  
      }
      username.addEventListener("focus", usernameFocus);
      password.addEventListener("focus", passwordFocus);
      //identify.addEventListener("focus", identifyFocus);
      //identify.addEventListener("blur", validate);
      idetifyCode.addEventListener("click", createCode);
      ////////////////////////////////////////////////////////////////
      var oRemember = document.getElementById('rememberCheckbox');
      //页面初始化时，如果帐号密码cookie存在则填充
      if (getCookie('username') && getCookie('password')) {
          username.value = getCookie('username');
          password.value = getCookie('password');
          oRemember.checked = true;
      }
      //复选框勾选状态发生改变时，如果未勾选则清除cookie
      oRemember.onchange = function() {
          if (!this.checked) {
              delCookie('username');
              delCookie('password');
          }
      };
      /////////////////////////////////////////////////////////////////
      loginButton.onclick = function login(e) {
          //阻止默认行为
          var e = e || window.event;
          e.preventDefault();
          if (username.value.length == 0) {
              document.getElementById("adressNull").style.display = "block";
          } else if (password.value.length == 0 && username.style.color == "black")
              document.getElementById("passwordNull").style.display = "block";
          else if (document.getElementById("identify").value.length == 0 && username.style.color == "black" && password.value.length > 0)
              alert("验证码错误!");
          else if (!validate()) {
              alert("验证码错误!");
          } else {
              // 请求的参数
              ////////
              //如果复选框是勾选状态则保存cookie
              if (oRemember.checked) {
                  setCookie('username', username.value, 7); //保存帐号到cookie，有效期7天
                  setCookie('password', password.value, 7); //保存密码到cookie，有效期7天
              }
              ////////
              var registerInfo = { 'Email': username.value, 'password': password.value };
              $.ajax({
                  headers: {
                      "Access-Control-Allow-Origin": "*"
                  },
                  type: "POST",
                  url: " ", //填入url
                  contentType: "application/json",
                  dataType: "json",
                  data: JSON.stringify(registerInfo),
                  success: function(result) {
                      window.location.href = "https://www.baidu.com/";
                  },
                  error: function(jqXHR, textStatus, errorThrown) {
                      if (jqXHR.status == 404)
                          alert("登陆失败！");
                  }
              });
          }
      }
  
  }
  
  function setCookie(name, value, day) {
      var date = new Date();
      date.setDate(date.getDate() + day);
      document.cookie = name + '=' + value + ';expires=' + date;
  };
  //获取cookie
  function getCookie(name) {
      var reg = RegExp(name + '=([^;]+)');
      var arr = document.cookie.match(reg);
      if (arr) {
          return arr[1];
      } else {
          return '';
      }
  };
  //删除cookie
  function delCookie(name) {
      setCookie(name, null, -1);
  };
  ```

### 6. 文件资源管理器主界面

 相关技术

- HTML
- CSS
- JavaScript 
- Vue.js
- Axios

#### 主要功能

- 文件重命名
- 文件名称排序（正/倒序）
- 文件大小排序（正/倒序）
- 修改日期排序（正/倒序）
- 自定义右键菜单
- 添加/删除文件

#### 实现效果

![image-20210201085529326](C:\Users\82604\AppData\Roaming\Typora\typora-user-images\image-20210201085529326.png)

#### 相关代码

- 文件重命名

  ```
  function addinput(e) {
    //先删掉所有编辑框
    var myinput = document.getElementsByClassName("fNameInput");
    for (var i = 0; i < myinput.length; i++) {
     // console.log(1);
      myinput[i].parentElement.removeChild(myinput[i].parentElement.childNodes[0]);
    }
    var formerFileName = e.target.innerHTML;
    var para = document.createElement("input");
    e.currentTarget.parentElement.insertBefore(para,e.currentTarget.parentElement.childNodes[0]); 
    e.currentTarget.parentElement.childNodes[0].setAttribute("id",inputIndex);
    e.currentTarget.parentElement.childNodes[0].value=formerFileName;
    e.currentTarget.parentElement.childNodes[0].setAttribute("style","width: 14.6%;height: 44px;position:absolute");
    e.currentTarget.parentElement.childNodes[0].setAttribute("class","fNameInput");
    e.currentTarget.parentElement.childNodes[0].setAttribute("type","text");
    e.currentTarget.parentElement.childNodes[0].setAttribute("maxlength","13");
    document.getElementById(inputIndex).addEventListener("blur", function () {
         newFileName(inputIndex);
    });
    inputIndex++;
  }
  //浮动编辑框失焦事件
  function newFileName(n) {
    n = n - 1;
    //console.log(e.target.innerHTML);
    var content = document.getElementById(n).value;
    document.getElementById(n).nextElementSibling.nextElementSibling.innerHTML = content;
  document.getElementById(n).parentElement.removeChild(document.getElementById(n).parentElement.childNodes[0]);
  
  }
  ```

- 文件名称排序

  ```
  //名称排序
  function arraySortByName(list, key) {
    if (list === undefined || list === null) return [];
    list.sort((a, b) => {
      let strA = a[key];
      let strB = b[key];
      // 谁为非法值谁在前面
      if (
        strA === undefined ||
        strA === null ||
        strA === "" ||
        strA === " " ||
        strA === "　"
      ) {
        return -1;
      }
      if (
        strB === undefined ||
        strB === null ||
        strB === "" ||
        strB === " " ||
        strB === "　"
      ) {
        return 1;
      }
      // 如果a和b中全部都是汉字，或者全部都非汉字
      if (
        (strA.split("").every((char) => notChinese(char)) &&
          strB.split("").every((char) => notChinese(char))) ||
        (strA.split("").every((char) => !notChinese(char)) &&
          strB.split("").every((char) => !notChinese(char)))
      ) {
        return strA.localeCompare(strB);
      } else {
        const charAry = strA.split("");
        for (const i in charAry) {
          if (charCompare(strA[i], strB[i]) !== 0) {
            return charCompare(strA[i], strB[i]);
          }
        }
        // 如果通过上面的循环对比还比不出来，就无解了，直接返回-1
        return -1;
      }
    });
    return list;
  }
  
  function charCompare(charA, charB) {
    // 谁为非法值谁在前面
    if (
      charA === undefined ||
      charA === null ||
      charA === "" ||
      charA === " " ||
      charA === "　"
    ) {
      return -1;
    }
    if (
      charB === undefined ||
      charB === null ||
      charB === "" ||
      charB === " " ||
      charB === "　"
    ) {
      return 1;
    }
    // 如果都为英文或者都为汉字则直接对比
    if (
      (notChinese(charA) && notChinese(charB)) ||
      (!notChinese(charA) && !notChinese(charB))
    ) {
      return charA.localeCompare(charB);
    } else {
      // 如果不都为英文或者汉字，就肯定有一个是英文，如果a是英文，返回-1，a在前，否则就是b是英文，b在前
      if (notChinese(charA)) {
        return -1;
      } else {
        return 1;
      }
    }
  }
  
  function notChinese(char) {
    const charCode = char.charCodeAt(0);
    return charCode >= 0 && charCode <= 128;
  }
  
  //大小排序
  //var arr = [23, 12, 1, 34, 116, 8, 18, 37, 56, 50];
  function sortSize(array, key) {
    return array.sort(function (a, b) {
      if (a[key] > b[key]) {
        return 1;
      } else if (a[key] < b[key]) {
        return -1;
      } else {
        return 0;
      }
    });
  }
  ```

- 文件大小排序

  ```
  function sortSize(array, key) {
    return array.sort(function (a, b) {
      if (a[key] > b[key]) {
        return 1;
      } else if (a[key] < b[key]) {
        return -1;
      } else {
        return 0;
      }
    });
  }
  ```

- 修改日期排序

  ```
  //时间排序(最近修改时间由远到近)
  function dateSort(array1, key1) {
    return array1.sort(function (a, b) {
      //console.log("时间排序");
      let aTimeString = a.fileModified;
      let bTimeString = b.fileModified;
      let aTime = new Date(aTimeString).getTime();
      let bTime = new Date(bTimeString).getTime();
      //let bTime=b.getTime();
      return bTime - aTime;
    });
  }
  ```

- 自定义右键菜单

  ```
  <ul v-show="visible" :style="{ left:left + 'px', top:top + 'px'}" class="contextmenu" >
    <li>打开</li>
    <li>删除</li>
    <li>下载</li>
    <li>预览</li>
    <li>编辑</li>
    <li>标签</li>
    <li @click="changeFileNameByMenu()">重命名</li>
  </ul>
  ```

  ```
  watch: {
      visible: function (value) {
        if (value) {
          document.body.addEventListener("click", this.closeMenu);
        } else {
          document.body.removeEventListener("click", this.closeMenu);
        }
      },
    }
  ```

  ```
  openMenu: function (e, index) {
    // this.rightClickItem = item;
    this.activeindex = index;
    let x = e.clientX;
    let y = e.clientY;
  
    this.top = y;
    this.left = x;
  
    this.visible = true;
  },
  closeMenu: function () {
    this.visible = false;
  },
  ```

  

- 添加/删除文件

  ```
  add: function () {
        this.list.push({
          fileName: "添加的文件",
          fileSize: "3KB",
          fileModified: "2018/07/23 09:49:33",
          fileType: "css",
        });
      },
  ```

  ```
  del: function () {
        this.list.splice(1, 1);
      },
  ```

## 三、心得体会：

**1.基础学习**

HTML+CSS+JavaScript一整套的知识庞杂又松散，如果不能熟练掌握基础，那么每次写代码就会像在玩拼图游戏，你无法准确拿到需要的拼图，只能够通过部分特征去大海捞针。这必然会浪费时间，降低效率，所以对于基础知识的反复记忆加练习是很有必要的，要在脑海中建立属于自己的知识体系框架才能熟练掌握这部分内容。

**2.细心**

在编写前端代码时，编译器通常只会对代码的格式错误进行提醒，某些拼写错误或是细节问题需要自己去排查。有时候可能是一个符号，或是一个单词，一不小心就会导致页面无法加载或是功能无法正常实现。因此写代码一定要耐心、细心，在经验不足的情况下，一个简单空格也能导致不断调试却无法找出bug的情况。在做文件列表选中改变背景颜色的时候，我将v-bind的缩写漏掉了“:"，致使class绑定的样式一直不起作用，最后花费两天的时间才搞明白自己的失误。

 **3.勤思考，多练习** 

起初我在做利用浮动编辑框实现文件名重命名时就犯了空想的毛病，想不明白就一直想，中期终于要动手试了，又产生了惰性思维，只去拷贝网上找来的代码，但别人的代码又不适用于自己的项目，最后发现自己不断琢磨提出想法并通过实践检验的过程才是收获最大的，也是效率最高的时候。况且很多时候代码的编写逻辑是相似的，但相似之余其中的一些细节不尽相同。勤思考才能发散思维，去解决多种多样的问题。多练习才能积累经验，才会知道如何将所学的知识在具体的场景里使用。

通过半年多时间的学习和练习，我在编程思想、能力和态度等方便都有了很大的提升。不过进步较大的主要原因是之前掌握的知识太少，而且有一段时间的学习进度可以说是停滞的。总的来说，自己还是应该更加努力更加专注，下一阶段的目标就是巩固基础，以及深化对vue框架的理解。
